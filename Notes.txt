ETCD is a distributed reliable key-value store that is simple, secure& fast
by default listen on port 2379
./etcdctl set key1 value1           # etcd command lines used to store and retrieve keys and values, it's version 2 command
./etcdctl --version
ETCDCTL_API=3 ./etcdctl version     # to make api version 3.3 rather than 2
./etcdctl put key1 value1           # to put value of key1
./etcdctl get key1                  # to get value of key1
---
#you must specify the ETCDCTL API version and path to certificate files
kubectl exec etcd-controlplane -n kube-system -- sh -c "ETCDCTL_API=3 etcdctl get / --prefix --keys-only --limit=10 --cacert /etc/kubernetes/pki/etcd/ca.crt --cert /etc/kubernetes/pki/etcd/server.crt --key /etc/kubernetes/pki/etcd/server.key"
---
shceduler decide which pod go to which node but the kubelet creates the pods 
kubeadm doesn't automatically install the kubelet but you must always manually install the kubelet on your worker nodes. download the installer, extract and and run it as a service
Kube-Proxy is a network proxy that runs on each node in a Kubernetes cluster. It is responsible for maintaining network connectivity between services and pods. 
Kube-Proxy does this by translating service definitions into actionable networking rules.

kubectl run nginx --image nginx
kubectl get pods                    # to get running pods 
#pods with YAML
file name is pod-definition.yml
---
apiVersion: v1
kind: Pod                           # could be replicaset, deployment, service 
metadata:                           # data about the object
  name: myapp-pod
  labels:
      app: myapp                    # everything under metadata is written as dictionary not string 
      type: front-end               # you can name it tier not type
spec:
  containers:                       # is a list or arrary because we could have multible containers within them
    - name: nginx-containers
      image: nginx 
#   - name: busybox
#     image: busybox
---
kubectl create -f pod-definition.yml #to create the pod 
kubectl get pods
kubectl describe pod myapp-pod      #to get all info and details about your pod 
kubectl create -f pod-definition.yml = kubectl apply -f pod-definition.yml
kubectl delete pod <podName>
kubectl apply -f pod-definition.yml 
kubectl get pods -o wide            # to get wide view for get pods 
kubectl run redis --image=redis123 --dry-run=client -o yaml        # to make it wihout creating the yaml file 
----------------
---ReplicationController---
---
apiVersion: v1
kind: ReplicationController        
metadata:                           #for application controller                 
  name: myapp-rc
  labels:
      app: myapp                    
      type: front-end               
spec:
  template:
    metadata:                        #for pods 
      name: myapp-pod
      labels:
          app: myapp                    
          type: front-end               
    spec:
      containers:                       
        - name: nginx-containers
          image: nginx 

  replicas: 2
---
kubectl create -f rc-definition.yml   #replication controller created 
kubectl get ReplicationController     #to get desired, current, ready, and age of RC created
---------------------------------------------------------------------------------------------
---ReplicaSet---
---
apiVersion: apps/v1
kind: ReplicaSet        
metadata:                           #for replicaset                
  name: myapp-replicaset
  labels:
      app: myapp                    
      type: front-end               
spec:
  template:
    metadata:                        #for pods 
      name: myapp-pod
      labels:
          app: myapp                    
          type: front-end               
    spec:
      containers:                       
        - name: nginx-containers
          image: nginx 

  replicas: 
  selector:                          # determine how many pods are under control of replicaset and this is performed with the matchlabel 
    matchLabels:
      type: front-end 
------------------------------------------------------------------------
kubectl create -f replicaset-definition.yml 
kubectl get replicaset
#replicaset monitor the pods so if there's a pod that fails, it will run a new one
kubectl replace -f replicaset-definition.yml                #after updating the replicas in the file at anytime, run this command to apply 
kubectl scale --replicas=6 -f replicaset-definition.yml     #rather that updating in file to update replicas number 
kubectl scale --replicas=6 -f replicaset-definition.yml = kubectl scale --replicas=6 replicaset myapp-replicaset
kubectl delete replicaset myapp-replicaset
kubectl explain replicaset                                  #to see version and kind 
kubectl get rs 
kubectl edit rs <replicasetname>                            #navigate to the replica manifest file 
-------------------------------------------------------------------------------
---deployment---
---
apiVersion: apps/v1
kind: Deployment        
metadata:                                     
  name: myapp-deployment
  labels:
      app: myapp                    
      type: front-end               
spec:
  template:
    metadata:                        
      name: myapp-pod
      labels:
          app: myapp                    
          type: front-end               
    spec:
      containers:                       
        - name: nginx-container
          image: nginx 

  replicas: 3
  selector:              
    matchLabels:
      type: front-end 
---
kubectl create -f deployment-definition.yml 
kubectl get deployments
#the deployment automatically create a replicaset 
kubectl get all                                           # to see all created objects
--------------------------------------------------------------------------------------
---Service---
---
apiVersion: v1
kind: Service        
metadata:                                     
  name: myapp-service 
  labels:
      app: myapp                    
      type: front-end               
spec:
  type: NodePort                                #default type is ClusterIP
  ports:
   - targetPort: 80
     port: 80                                   #if you don't provide port,it's by default 80
     nodePort: 30008                            #if you don't provide nodePort,it's by default from 30000 to 32767
  selector:                                     #pull the labels from the pod definition file and put them under selector
     app: myapp
     type: front-end  
---
kubectl create -f service-definition.yml 
kubectl get services
#to set type to LoadBalancer, you need to integrate to a LoadBalancer service like ELB services from the cloud providers 
#Namespaces provide a scope for names. Names of resources need to be unique within a namespace, but not across namespaces. 
#Namespaces cannot be nested inside one another and each Kubernetes resource can only be in one namespace.
#Namespaces are a way to divide cluster resources between multiple users (via resource quota).

mysql.connect("db-service")                         # to connect to a database in the same namespace
mysql.connect("db-service.dev.svc.cluster.local")   #to connect to a database in another namespace(servicename.namespace.svc.cluster.local)format
#cluster.local is the default domain name of the k8s cluster and svc is the subdomain (service )

kubectl get pods --namespace=<namespaceName>        #to get pods in a specific namespace and not the default one
kubectl create -f pod-definition.yml --namespace=dev
---------------------
---NameSpace---
---
apiVersion: v1
kind: Namespace
metadata:
    name: dev
---
kubectl create -f namespace-dev.yml
kubectl create namespace dev
kubectl config set-context $(kubectl config current-context) --namespace=dev      #to move permanently to this namespace 
kubectl get pods --all-namespaces
kubectl get pods -n=finance
kubectl run redis --image=redis -n=finance  #run pod named redis with image and namespace 
----------------------------------
#to limit resources of cluster within a namespace define a quota
---
apiVersion: v1
kind: ResourceQuota
metadata:
    name: compute-quota
    namespace: dev 
spec:
  hard:
    pods: "10"
    requests.cpu: "4"
    requests.memory: 5Gi
    limits.cpu: "10"
    limits.memory: 10Gi
---
kubectl get pods --all-namespaces = kubectl get pods -A 
kubectl get svc -n=<namespaceName>                        #get services in specific namespace
kubectl set image deployment nginx nginx=nginx:1.18 
kubectl expose deployment nginx --port 80
#--dry-run: By default as soon as the command is run, the resource will be created. If you simply want to test your command , use the --dry-run=client option. 
#This will not create the resource, instead, tell you whether the resource can be created and if your command is right.
#-o yaml: This will output the resource definition in YAML format on screen.


#Create a Service named redis-service of type ClusterIP to expose pod redis on port 6379 (This will automatically use the podâ€™s labels as selectors)
kubectl expose pod redis --port=6379 --name redis-service --dry-run=client -o yaml

kubectl create service clusterip httpd --tcp=80:80
-----------------------------------------------------------------------------
#without a scheduler, the easiest way to shcedule a pod is to simply set the nodeName field to the name of the node in the pod spec file "parallel to containers:"
#if you want to add an existing pod to a node, create a binding object and send a post request to the pod binding API thus mimicking what 
the actual scheduler does. 
---
apiVersion: v1
kind: Binding
metadata:
  name: nginx
target:
  apiVersion: v1
  kind: node
  name: <nameoftargetnode>
  ---
  curl --header "content-type:application/json" --request POST --data '{"apiVersion":"v1", "kind": "Binding"...}
kubectl get pods -n kube-system                           #show the k8s system pods like etcd, scheduler..
kubectl replace --force -f nginx.yaml                     #rather that delete and create the pod again
kubectl get pods --watch 
kubectl get pods --selector <labelname>=<labelvalue>      #to select a pod with a label 
#You can use Kubernetes annotations to attach arbitrary non-identifying metadata to objects. Clients such as tools and libraries can retrieve this metadata.
#annotations are not used to identify and select objects. 
#The metadata in an annotation can be small or large, structured or unstructured, and can include characters not permitted by labels. 
#It is possible to use labels as well as annotations in the metadata of the same object.
///
"metadata": {
  "annotations": {
    "key1" : "value1",
    "key2" : "value2"
  }
}
///
kubectl get all --selector env=prod,bu=finance,tier=frontend        #give a pod shared with all these selectors 
kubectl get pods --selector env=dev --no-headers | wc -l            #get number of pods with label env dev 
--------------------------------------
---Taints and Tolerations---
kubectl taint nodes <nodename> key=value:taint-effect               #to taint a node
#there are three main effects: NoSchedule PreferNoSchedule NoExecute
#https://www.hackertouch.com/what-is-the-difference-between-noexecute-noschedule-prefernoschedule.html  #to explain difference
